var documenterSearchIndex = {"docs":
[{"location":"methods/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"methods/","page":"Manual","title":"Manual","text":"Modules = [AutoSymPTR]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"methods/#AutoSymPTR.autosymptr-Tuple{Any, Basis}","page":"Manual","title":"AutoSymPTR.autosymptr","text":"autosymptr(f, B::AbstractMatrix, [syms=nothing]; atol=0, rtol=sqrt(eps()), maxevals=typemax(Int64), buffer=nothing)\n\nComputes the integral of f to within the specified tolerances and returns a tuple (I, E, numevals, rules) containing the estimated integral, the estimated error, the number of integrand evaluations. The integral on the symmetrized domain needs to be mapped back to the full domain by the caller, since for array-valued integrands this depends on the representation of the integrand under the action of the symmetries.\n\nNote that if a vector buffer is provided to store integrand evaluations, the integrand evaluations will be parallelized and it will be assumed that the integrand is threadsafe.\n\nnote: Convergence depends on periodicity\nIf the routine takes a long time to return, double check that the period of the function f along the basis vectors in the columns of B is consistent.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Internal","page":"Manual","title":"Internal","text":"","category":"section"},{"location":"methods/","page":"Manual","title":"Manual","text":"These methods are internal and may change between AutoSymPTR.jl releases","category":"page"},{"location":"methods/","page":"Manual","title":"Manual","text":"AutoSymPTR.PTR\nAutoSymPTR.alloc_cache\nAutoSymPTR.AffineQuad\nAutoSymPTR.symptr_rule\nAutoSymPTR.InplaceIntegrand","category":"page"},{"location":"methods/#AutoSymPTR.PTR","page":"Manual","title":"AutoSymPTR.PTR","text":"PTR{d}(x::AbstractVector{T}) where {d,T}\n\nStores a d dimensional Cartesian product grid of SVector{d,T}. Similar to Iterators.product(ntuple(n->x, d)...). Uses the same number of grid points per dimension.\n\n\n\n\n\n","category":"type"},{"location":"methods/#AutoSymPTR.alloc_cache","page":"Manual","title":"AutoSymPTR.alloc_cache","text":"alloc_cache(::Type{T}, ::Val{d}, rule)\n\nInitialize an empty buffer of PTR rules evaluated from rule(T,Val(d)) where T is the domain type and d is the number of dimensions.\n\nnote: For developers\nProviding a special rule, (e.g. PTR)\n\n\n\n\n\n","category":"function"},{"location":"methods/#AutoSymPTR.AffineQuad","page":"Manual","title":"AutoSymPTR.AffineQuad","text":"AffineQuad(rule, A, b, c, vol)\n\nA wrapper to an iterable and indexable quadrature rule that applies an affine coordinate transformation to the nodes of the form A*(x+c)+b. While the weights should be rescaled by the Jacobian determinant vol=abs(det(A)), the value is stored in the vol field of the struct so that the caller can minimize multiplication by applying the rescaling after computing the rule.\n\nWhile the quadrature rule should be unitless, the affine transform may have units.\n\n\n\n\n\n","category":"type"},{"location":"methods/#AutoSymPTR.symptr_rule","page":"Manual","title":"AutoSymPTR.symptr_rule","text":"symptr_rule(npt, ::Val{d}, syms, T::Integer=UInt8) where {d}\n\nReturns wsym, a npt^d array containing the T::Integer weights of the symmetrized PTR quadrature, aka the Monkhorst Pack weights, flag a tuple of boolean arrays that indicate whether a slice of wsym has nonzero entries, and nsym the number of non-zero weights. (see Algorithm 3. in Kaye et al.). The algorithm is serial and has time and memory requirements scaling as O(npt^d).\n\nThe arithmetic precision for the calculation is inferred from the element type of syms and the integer size needs to be increased proportionally to the size of syms. The default value of UInt8 is sufficient for the 48 possible symmetries in 3d.\n\n\n\n\n\n","category":"function"},{"location":"methods/#AutoSymPTR.InplaceIntegrand","page":"Manual","title":"AutoSymPTR.InplaceIntegrand","text":"InplaceIntegrand(f!, result::AbstractArray)\n\nConstructor for a InplaceIntegrand accepting an integrand of the form f!(y,x). The caller also provides an output array needed to store the result of the quadrature. Intermediate y arrays are allocated during the calculation, and the final result is may or may not be written to result, so use the IntegralSolution immediately after the calculation to read the result, and don't expect it to persist if the same integrand is used for another calculation.\n\n\n\n\n\n","category":"type"},{"location":"#AutoSymPTR.jl","page":"Home","title":"AutoSymPTR.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AutoSymPTR","category":"page"},{"location":"#AutoSymPTR","page":"Home","title":"AutoSymPTR","text":"A package implementing the automatic symmetrized periodic trapezoidal rule (PTR) for spectrally-accurate integration of periodic functions with the algorithm described by Kaye et al.. The main routine is autosymptr, which computes the integral of a periodic function to within a requested error tolerance. If nontrivial symmetries are provided, the routines return the integral on the symmetry-reduced domain, since it is generally up to the caller to implement the mapping back to the full domain, which is nontrivial in cases with non-scalar integrands. A simple example is\n\nusing LinearAlgebra, AutoSymPTR\nautosymptr(x -> 1 + mapreduce(y -> cospi(2y), +, x), I(3))[1] â‰ˆ 1\n\n\n\n\n\n","category":"module"}]
}
